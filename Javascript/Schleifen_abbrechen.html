<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Eine universelle Lernplattform, um HTML, CSS und JavaScript zu lernen.">
    <meta name="author" content="CodeBloom">
    <meta name="keywords" content="Programmieren, HTML, CSS, JavaScript, Lernen, Webentwicklung">
    <title>CodeBloom</title>
    <!-- FÃ¼ge hier weitere Metadaten oder Links hinzu -->
    <link rel="stylesheet" href="../../../src/css/style.css">
</head>

<body>
    <header>
        <nav>
            <ul class="navbar">
                <li><a href="../../../main.html">Home</a></li>
                <li><a href="../../../src/html/wichtigeLinks.html">Links</a></li>
                <li><a href="../../../src/html/buecher.html">BÃ¼cher</a></li>
                <li><a href="../../../src/html/projekte.html">Projekte</a></li>
                <li><a href="../../../src/html/HTML/htmlindex.html">HTML</a></li>
                <li><a href="../../../src/html/CSS/cssindex.html">CSS</a></li>
                <li><a href="../../../src/html/JavaScript/javascriptindex.html">JavaScript</a></li>
                <!-- Weitere Navbar-Links kÃ¶nnen hinzugefÃ¼gt werden -->
            </ul>
        </nav>
    </header>

    <main>
        <section class="chapter">
            <h1>Schleifen abbrechen wie ein Boss: <code>break</code>, <code>continue</code> &amp; Co. ğŸ§¨</h1>
            <p>
                Willkommen zurÃ¼ck, Abenteurer*in! Heute lernst du, wie du aus endlosen Schleifen aussteigen kannst wie
                ein echter Raid-Leader: Mit einem klaren "Stop!" ğŸ’¥
                Denn nicht jede Schleife muss bis zum bitteren Ende durchlaufen - manchmal musst du mitten im Gefecht
                sagen: â€Genug ist genug!â€œ
            </p>
            <p>
                In diesem Kapitel zeigen wir dir, wie du mit <code>break</code>, <code>continue</code> und
                <code>return</code> die Kontrolle Ã¼ber deine Schleifen Ã¼bernimmst. Egal, ob du ein Monster besiegen,
                einen Schatz finden oder einfach nur den nÃ¤chsten Level erreichen willst - diese Tricks helfen dir,
                schneller ans Ziel zu kommen! ğŸš€
            </p>
            <p>
                Lass uns gleich loslegen und die Geheimnisse der Schleifensteuerung lÃ¼ften! Und keine Sorge, wir
                haben auch ein paar coole Beispiele und Ãœbungen fÃ¼r dich vorbereitet. Also schnapp dir deinen
                Zauberstab (oder deine Tastatur) und lass uns starten! ğŸª„
            </p>
        </section>

        <section class="chapter">
            <h2><code>break</code> - Der Notausgang ğŸ›‘</h2>
            <p>
                <code>break</code> verlÃ¤sst sofort die aktuelle Schleife - stell dir vor, du bist in einem Dungeon und
                entdeckst eine Falle. Was machst du? Genau - raus da!
            </p>
<pre><code>for (let i = 1; i &lt;= 10; i++) {
if (i === 5) {
console.log("Monster zu stark! Flucht bei Stufe " + i);
break; // Schleife wird hier beendet
}
console.log("Stufe " + i + " geschafft!");
}</code></pre>
            <p>
                In diesem Beispiel wird die Schleife abgebrochen, wenn die Stufe 5 erreicht ist. Du kannst auch
                <code>break</code> in <code>while</code>-Schleifen verwenden - es funktioniert Ã¼berall dort, wo du
                eine Schleife hast.
            </p>
            <pre><code>let i = 1;
while (i &lt;= 10) {
if (i === 5) {
console.log("Monster zu stark! Flucht bei Stufe " + i);
break; // Schleife wird hier beendet
}
console.log("Stufe " + i + " geschafft!");
i++;
}</code></pre>
            <p>
                Hier wird die Schleife ebenfalls abgebrochen, wenn die Stufe 5 erreicht ist. Du kannst auch
                <code>break</code> in <code>switch</code>-Anweisungen verwenden, um den aktuellen Fall zu beenden.
            </p>
            <pre><code>let waffe = "Schwert";
switch (waffe) {
case "Schwert":
console.log("Du hast ein Schwert! âš”ï¸");
break; // Beendet den switch-Fall
case "Bogen":
console.log("Du hast einen Bogen! ğŸ¹");
break; // Beendet den switch-Fall
default:
console.log("Unbekannte Waffe! â“");
break; // Beendet den switch-Fall
}</code></pre>
            <p>
                Hier wird der aktuelle Fall beendet, wenn die Waffe ein Schwert ist. Wenn du kein <code>break</code>
                verwendest, wird der Code in den nÃ¤chsten Fall weiter ausgefÃ¼hrt - das kann zu unerwarteten Ergebnissen
                fÃ¼hren.
            </p>
        </section>

        <section class="chapter">
            <h2><code>continue</code> - Der Trickser ğŸ¦Š</h2>
            <p>
                Mit <code>continue</code> Ã¼berspringst du nur den aktuellen Durchlauf und springst direkt zur nÃ¤chsten
                Runde. Ideal, wenn du etwas auslassen, aber nicht komplett abbrechen willst - wie ein Rogue, der sich
                unauffÃ¤llig vorbeischleicht.
            </p>
            <pre><code>for (let i = 1; i &lt;= 5; i++) {
  if (i === 3) {
    console.log("Runde " + i + " Ã¼bersprungen ğŸš«");
    continue;
  }
  console.log("Runde " + i + " abgeschlossen âœ…");
}</code></pre>
            <p>
                In diesem Beispiel wird die Runde 3 Ã¼bersprungen, aber die Schleife lÃ¤uft weiter. Das ist nÃ¼tzlich,
                wenn du bestimmte Bedingungen hast, die du ignorieren mÃ¶chtest, aber trotzdem den Rest der Schleife
                durchlaufen willst.
            </p>
            <pre><code>let i = 1;
while (i &lt;= 5) {
    if (i === 3) {
        console.log("Runde " + i + " Ã¼bersprungen ğŸš«")
        continue;
    }
    console.log("Runde " + i + " abgeschlossen âœ…")
    i++;
}</code></pre>
            <p>
                Hier wird die Runde 3 ebenfalls Ã¼bersprungen, aber die Schleife lÃ¤uft weiter. Du kannst auch
                <code>continue</code> in <code>switch</code>-Anweisungen verwenden, um den aktuellen Fall zu
                Ã¼berspringen.
            </p>
            <pre><code>let waffe = "Schwert";
switch (waffe) {
case "Schwert":
console.log("Du hast ein Schwert! âš”ï¸");
continue; // Ãœberspringt den aktuellen Fall
case "Bogen":
console.log("Du hast einen Bogen! ğŸ¹");
continue; // Ãœberspringt den aktuellen Fall
default:
console.log("Unbekannte Waffe! â“");
continue; // Ãœberspringt den aktuellen Fall
}</code></pre>
            <p>
                Hier wird der aktuelle Fall Ã¼bersprungen, wenn die Waffe ein Schwert ist. Wenn du kein
                <code>continue</code> verwendest, wird der Code in den nÃ¤chsten Fall weiter ausgefÃ¼hrt - das kann zu
                unerwarteten Ergebnissen fÃ¼hren.
            </p>
        </section>

        <section class="chapter">
            <h2><code>return</code> in Funktionen - Der Heimweg ğŸ </h2>
            <p>
                Wenn du dich in einer Funktion befindest, kannst du mit <code>return</code> nicht nur die Schleife,
                sondern gleich die gesamte Funktion verlassen - wie ein Magier, der sich mit einem Teleport-Zauber aus
                dem Staub macht.
            </p>
<pre><code>function kÃ¤mpfe(bossLevel) {
for (let i = 1; i &lt;= bossLevel; i++) {
if (i === 4) {
console.log("Boss zu stark - RÃ¼ckzug!");
return;
}
console.log("Angriff auf Boss-Stufe " + i);
}
console.log("Kampf vorbei!");
}

kÃ¤mpfe(6);</code></pre>
            <p>
                In diesem Beispiel wird die Funktion abgebrochen, wenn die Boss-Stufe 4 erreicht ist. Das ist nÃ¼tzlich,
                wenn du eine Funktion hast, die mehrere Schleifen enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <pre><code>function monsterSuchen(monsterListe) {
for (let i = 0; i &lt; monsterListe.length; i++) {
if (monsterListe[i] === "Drache") {
console.log("Drache gefunden! ğŸ‰");
return; // Funktion wird hier beendet
}
console.log("Monster " + monsterListe[i] + " gefunden!");
}
console.log("Suche abgeschlossen!");
}

monsterSuchen(["Goblin", "Ork", "Drache", "Zentaur"]);</code></pre>
            <p>
                Hier wird die Funktion beendet, wenn ein Drache gefunden wird. Das ist nÃ¼tzlich, wenn du eine
                Funktion hast, die mehrere Schleifen enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <p>
                <code>return</code> kann auch in <code>switch</code>-Anweisungen verwendet werden, um die gesamte
                Funktion zu beenden.
            </p>
            <pre><code>function waffenSwitch(waffe) {
switch (waffe) {
case "Schwert":
console.log("Du hast ein Schwert! âš”ï¸");
return; // Funktion wird hier beendet
case "Bogen":
console.log("Du hast einen Bogen! ğŸ¹");
return; // Funktion wird hier beendet
case "Zauberstab":
console.log("Du hast einen Zauberstab! ğŸª„");
return; // Funktion wird hier beendet
default:
console.log("Unbekannte Waffe! â“");
return; // Funktion wird hier beendet
}
}

waffenSwitch("Schwert");</code></pre>
            <p>
                Hier wird die Funktion beendet, wenn die Waffe ein Schwert ist. Das ist nÃ¼tzlich, wenn du eine
                Funktion hast, die mehrere Schleifen enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <p>
                <code>return</code> kann auch in <code>try...catch</code>-Anweisungen verwendet werden, um die
                gesamte Funktion zu beenden.
            </p>
        </section>

        <section class="chapter">
            <h1>Best Practices ğŸ¯</h1>
            <ul>
                <li>Verwende <code>break</code> fÃ¼r vorzeitiges Schleifenende - aber mit Bedacht!</li>
                <li><code>continue</code> ist super fÃ¼r Filterfunktionen oder Ã¼berspringbare Schritte.</li>
                <li><code>return</code> nur in Funktionen, niemals allein in der Schleife.</li>
                <li>Kommentiere gut, wenn du Schleifen frÃ¼hzeitig beendest - fÃ¼r Mitstreiter und zukÃ¼nftiges Ich!</li>
                <li>Vermeide zu viele verschachtelte <code>break</code>s - sonst wird's unÃ¼bersichtlich!</li>
                <li>Teste deinen Code grÃ¼ndlich - manchmal ist der Ausstieg nicht so einfach, wie du denkst!</li>
                <li>Nutze <code>break</code>, <code>continue</code> und <code>return</code> strategisch - sie sind
                    mÃ¤chtige Werkzeuge!</li>
                <li>Vermeide endlose Schleifen - sie sind wie ein Labyrinth ohne Ausgang!</li>
                <li>Denke daran, dass <code>break</code> und <code>continue</code> nur in Schleifen funktionieren -
                    nicht in Funktionen!</li>
                <li>Verwende <code>return</code>, um Werte aus Funktionen zurÃ¼ckzugeben - nicht nur zum Beenden!</li>
                <li>Teste deinen Code regelmÃ¤ÃŸig - so findest du Fehler schneller!</li>
                <li>Nutze Debugging-Tools, um den Code Schritt fÃ¼r Schritt zu durchlaufen - so siehst du, was passiert!</li>
                <li>Verwende <code>console.log()</code>, um den Status deiner Variablen zu Ã¼berprÃ¼fen - so siehst du,
                    was passiert!</li>
                <li>Verwende <code>debugger;</code>, um den Code an einer bestimmten Stelle anzuhalten - so kannst du
                    den Status deiner Variablen Ã¼berprÃ¼fen!</li>
                <li>Verwende <code>try...catch</code>, um Fehler abzufangen - so kannst du den Code trotzdem
                    ausfÃ¼hren!</li>
                <li>Verwende <code>finally</code>, um Code auszufÃ¼hren, egal ob ein Fehler aufgetreten ist oder nicht -
                    so kannst du sicherstellen, dass der Code immer ausgefÃ¼hrt wird!</li>
                <li>Verwende <code>throw</code>, um eigene Fehler zu werfen - so kannst du den Code anpassen!</li>
            </ul>
        </section>

        <section class="chapter">
            <h2>Praktisches Beispiel: Loot-Suche ğŸ§°</h2>
<pre><code>let loot = ["Gold", "Heiltrank", "SchlÃ¼ssel", "Leeres Fass", "LegendÃ¤res Schwert"];

for (let i = 0; i &lt; loot.length; i++) {
if (loot[i] === "Leeres Fass") {
continue; // Zeitverschwendung - weitersuchen
}
if (loot[i] === "LegendÃ¤res Schwert") {
console.log("Beute gefunden: " + loot[i] + " ğŸ—¡ï¸");
break; // Mission erfÃ¼llt - ab nach Hause!
}
console.log("Untersuche: " + loot[i]);
}</code></pre>
            <p>
                In diesem Beispiel durchsuchen wir eine Liste von Loot-Items. Wenn wir ein leeres Fass finden, Ã¼berspringen
                wir es mit <code>continue</code>. Wenn wir das legendÃ¤re Schwert finden, brechen wir die Schleife mit
                <code>break</code> ab. So sparen wir Zeit und Nerven! â³
            </p>
            <p>
                Du kannst auch <code>return</code> verwenden, um die gesamte Funktion zu beenden, wenn du das
                legendÃ¤re Schwert gefunden hast. Das ist nÃ¼tzlich, wenn du eine Funktion hast, die mehrere Schleifen
                enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <pre><code>function lootSuchen(loot) {
for (let i = 0; i &lt; loot.length; i++) {
if (loot[i] === "Leeres Fass") {
continue; // Zeitverschwendung - weitersuchen

}
if (loot[i] === "LegendÃ¤res Schwert") {
console.log("Beute gefunden: " + loot[i] + " ğŸ—¡ï¸");
return; // Mission erfÃ¼llt - ab nach Hause!
}
console.log("Untersuche: " + loot[i]);
}
}

lootSuchen(["Gold", "Heiltrank", "SchlÃ¼ssel", "Leeres Fass", "LegendÃ¤res Schwert"]);</code></pre>
            <p>
                Hier wird die Funktion beendet, wenn das legendÃ¤re Schwert gefunden wird. Das ist nÃ¼tzlich, wenn du
                eine Funktion hast, die mehrere Schleifen enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <p>
                Du kannst auch <code>return</code> verwenden, um die gesamte Funktion zu beenden, wenn du das
                legendÃ¤re Schwert gefunden hast. Das ist nÃ¼tzlich, wenn du eine Funktion hast, die mehrere Schleifen
                enthÃ¤lt und du nur eine davon abbrechen mÃ¶chtest.
            </p>
            <p>
                Und das Beste daran? Du kannst diese Tricks in deinen eigenen Projekten verwenden, um deine
                Schleifensteuerung zu optimieren und deine Quests schneller abzuschlieÃŸen! ğŸ†
            </p>
            <p>
                Also, worauf wartest du noch? Schnapp dir deinen Code und leg los! Und vergiss nicht, uns deine
                Ergebnisse zu zeigen - wir sind gespannt auf deine Loot-Suche! ğŸ‰
            </p>
        </section>

        <section class="chapter">
            <h2>Fragen mit Antworten ğŸ§ </h2>
            <ol>
                <li><strong>Was macht <code>break</code> in einer Schleife?</strong><br>Beendet die Schleife sofort.
                </li>
                <li><strong>Was ist der Unterschied zu <code>continue</code>?</strong><br><code>continue</code>
                    Ã¼berspringt nur den aktuellen Schleifendurchlauf.</li>
                <li><strong>Kann ich <code>break</code> in <code>while</code>-Schleifen verwenden?</strong><br>Ja,
                    absolut!</li>
                <li><strong>Was passiert nach <code>break</code>?</strong><br>Der Code nach der Schleife wird
                    fortgesetzt.</li>
                <li><strong>Wo kann ich <code>return</code> verwenden?</strong><br>Nur in Funktionen, um sie frÃ¼hzeitig
                    zu beenden.</li>
                <li><strong>Kann ich <code>return</code> in Schleifen verwenden?</strong><br>Ja, aber nur innerhalb
                    von Funktionen.</li>
                <li><strong>Was passiert, wenn ich <code>return</code> in einer Schleife ohne Funktion benutze?</strong><br>
                    Das fÃ¼hrt zu einem Fehler, weil <code>return</code> nur in Funktionen gÃ¼ltig ist.</li>
                <li><strong>Kann ich <code>break</code> in <code>switch</code>-Anweisungen verwenden?</strong><br>Ja,
                    <code>break</code> beendet den aktuellen Fall.</li>
                <li><strong>Was passiert, wenn ich kein <code>break</code> in <code>switch</code> benutze?</strong><br>
                    Der Code im nÃ¤chsten Fall wird ebenfalls ausgefÃ¼hrt.</li>
                <li><strong>Wie kann ich endlose Schleifen vermeiden?</strong><br>Stelle sicher, dass die Schleifenbedingung
                    irgendwann falsch wird.</li>
                <li><strong>Was ist der Unterschied zwischen <code>break</code> und <code>return</code>?</strong><br>
                    <code>break</code> beendet nur die Schleife, wÃ¤hrend <code>return</code> die gesamte Funktion
                    verlÃ¤sst.</li>
                <li><strong>Kann ich <code>continue</code> in <code>switch</code>-Anweisungen verwenden?</strong><br>Ja,
                    <code>continue</code> Ã¼berspringt den aktuellen Fall.</li>
                <li><strong>Was passiert, wenn ich kein <code>continue</code> in <code>switch</code> benutze?</strong><br>
                    Der Code im nÃ¤chsten Fall wird ebenfalls ausgefÃ¼hrt.</li>
                <li><strong>Wie kann ich den Code in einer Schleife debuggen?</strong><br>Verwende <code>console.log()</code>
                    oder Debugging-Tools, um den Code Schritt fÃ¼r Schritt zu durchlaufen.</li>
                <li><strong>Was ist der Unterschied zwischen <code>try...catch</code> und <code>if...else</code>?</strong><br>
                    <code>try...catch</code> fÃ¤ngt Fehler ab, wÃ¤hrend <code>if...else</code> Bedingungen Ã¼berprÃ¼ft.</li>
            </ol>
        </section>

        <section class="chapter">
            <h2>HÃ¤ufige Fehler und LÃ¶sungen âš ï¸</h2>
            <ul>
                <li><strong>Fehler:</strong> <code>break</code> auÃŸerhalb einer Schleife<br><strong>LÃ¶sung:</strong> Nur
                    innerhalb von <code>for</code>, <code>while</code> oder <code>switch</code> verwenden</li>
                <li><strong>Fehler:</strong> <code>continue</code> endet Schleife<br><strong>LÃ¶sung:</strong>
                    <code>continue</code> springt nur zur nÃ¤chsten Runde</li>
                <li><strong>Fehler:</strong> <code>return</code> auÃŸerhalb einer Funktion<br><strong>LÃ¶sung:</strong> In
                    eine Funktion packen</li>
                <li><strong>Fehler:</strong> Schleife lÃ¤uft weiter nach <code>break</code><br><strong>LÃ¶sung:</strong>
                    Code genau prÃ¼fen - vielleicht steckt das <code>break</code> in einem <code>if</code> ohne
                    Bedingung?</li>
                <li><strong>Fehler:</strong> Zu viele verschachtelte Schleifen<br><strong>LÃ¶sung:</strong> Lieber in
                    Funktionen aufteilen</li>
                <li><strong>Fehler:</strong> Endlose Schleife<br><strong>LÃ¶sung:</strong> Bedingung Ã¼berprÃ¼fen -
                    vielleicht fehlt ein <code>i++</code>?</li>
                <li><strong>Fehler:</strong> <code>break</code> in einer Funktion<br><strong>LÃ¶sung:</strong> Nur in
                    Schleifen verwenden</li>
                <li><strong>Fehler:</strong> <code>continue</code> in einer Funktion<br><strong>LÃ¶sung:</strong> Nur in
                    Schleifen verwenden</li>
                <li><strong>Fehler:</strong> <code>return</code> in einer Schleife<br><strong>LÃ¶sung:</strong> Nur in
                        Funktionen verwenden</li>
                <li><strong>Fehler:</strong> <code>break</code> in einer Funktion<br><strong>LÃ¶sung:</strong> Nur in
                    Schleifen verwenden</li>
                <li><strong>Fehler:</strong> <code>continue</code> in einer Funktion<br><strong>LÃ¶sung:</strong> Nur in
                    Schleifen verwenden</li>
                <li><strong>Fehler:</strong> <code>return</code> in einer Schleife<br><strong>LÃ¶sung:</strong> Nur in
                    Funktionen verwenden</li>
            </ul>
        </section>

        <section class="chapter">
            <h2>Ãœbungen mit steigendem Schwierigkeitsgrad ğŸ§ª</h2>
            <ol>
                <li>Erstelle eine Schleife, die Zahlen von 1 bis 10 ausgibt, aber bei 5 abbricht.</li>
                <li>Gib alle Zahlen von 1 bis 10 aus, auÃŸer 7 (mit <code>continue</code>).</li>
                <li>Durchlaufe ein Array mit FrÃ¼chten, brich ab, wenn â€Ananasâ€œ gefunden wird.</li>
                <li>In einer <code>while</code>-Schleife: zÃ¤hle rÃ¼ckwÃ¤rts, Ã¼berspringe gerade Zahlen.</li>
                <li>In einer Funktion: PrÃ¼fe in einer Schleife, ob eine Zahl im Array <code>[2, 4, 6, 8]</code> ungerade
                    ist. Wenn ja, <code>return</code>.</li>
                <li>Erstelle eine Funktion, die ein Array von Zahlen durchlÃ¤uft und bei der ersten Zahl grÃ¶ÃŸer als 10
                    abbricht.</li>
                <li>Erstelle eine Schleife, die von 1 bis 20 zÃ¤hlt, aber bei 15 abbricht und â€Ziel erreicht!â€œ ausgibt.</li>
                <li>Durchlaufe ein Array mit Tieren und Ã¼berspringe â€Katzeâ€œ.</li>
                <li>In einer Funktion: ZÃ¤hle von 1 bis 100, aber gib nur die Zahlen aus, die durch 5 teilbar sind.</li>
                <li>Erstelle eine Schleife, die von 1 bis 50 zÃ¤hlt, aber bei 25 abbricht und â€Halbzeit!â€œ ausgibt.</li>
                <li>Durchlaufe ein Array mit Farben und Ã¼berspringe â€Blauâ€œ.</li>
                <li>In einer Funktion: ZÃ¤hle von 1 bis 100, aber gib nur die Zahlen aus, die durch 3 teilbar sind.</li>
                <li>Erstelle eine Schleife, die von 1 bis 100 zÃ¤hlt, aber bei 50 abbricht und â€Ziel erreicht!â€œ ausgibt.</li>
            </ol>
        </section>

        <section class="chapter">
            <h2>Projektideen ğŸ’¡</h2>
            <ol>
                <li><strong>Bosskampf-Simulation</strong>: Wenn Leben auf 0 fÃ¤llt, <code>break</code></li>
                <li><strong>Monsterfilter</strong>: Ãœberspringe Monster unter Level 5</li>
                <li><strong>GeheimtÃ¼r-Finder</strong>: Brich Schleife ab, wenn GeheimtÃ¼r gefunden wird</li>
                <li><strong>Dialogsystem</strong>: Wiederhole Fragen, bis Spieler â€Jaâ€œ sagt</li>
                <li><strong>Code-Schnitzeljagd</strong>: Suche ein bestimmtes Item in einer Liste</li>
                <li><strong>Loot-Generator</strong>: Erstelle eine Liste von Items, Ã¼berspringe leere</li>
                <li><strong>RÃ¤tsel-LÃ¶sung</strong>: Brich ab, wenn Spieler die richtige Antwort gibt</li>
                <li><strong>Quest-Tracker</strong>: ZÃ¤hle Quests, Ã¼berspringe abgeschlossene</li>
                <li><strong>Inventar-System</strong>: ZÃ¤hle Items, Ã¼berspringe leere</li>
                <li><strong>Charakter-Statistik</strong>: ZÃ¤hle Level, Ã¼berspringe niedrigere</li>
                <li><strong>Monster-Spawn-System</strong>: ZÃ¤hle Monster, Ã¼berspringe besiegte</li>
                <li><strong>Loot-Filter</strong>: ZÃ¤hle Items, Ã¼berspringe leere</li>
                <li><strong>Quest-Log</strong>: ZÃ¤hle Quests, Ã¼berspringe abgeschlossene</li>
                <li><strong>Charakter-Statistik</strong>: ZÃ¤hle Level, Ã¼berspringe niedrigere</li>
            </ol>
        </section>

        <section class="chapter">
            <h2>Speed Debugging-Challenges ğŸ› ï¸</h2>
            <ol>
                <li><code>if (i = 5) break;</code><br><strong>Fix:</strong> <code>i === 5</code></li>
                <li><code>return "Fertig";</code> auÃŸerhalb einer Funktion<br><strong>Fix:</strong> <code>return</code>
                    in Funktion packen</li>
                <li><code>continue</code> beendet Schleife vorzeitig<br><strong>Fix:</strong> ErklÃ¤re Unterschied
                    zwischen <code>break</code> und <code>continue</code></li>
                <li><code>while (true) { break; }</code><br><strong>Fix:</strong> Bedingung anpassen</li>
                <li><code>for (let i = 0; i &lt; 10; i++) { if (i === 5) return; }</code><br><strong>Fix:</strong> <code>return</code> in Funktion packen</li>
                <li><code>for (let i = 0; i &lt; 10; i++) { if (i === 5) continue; }</code><br><strong>Fix:</strong>
                    <code>continue</code> Ã¼berspringt nur den aktuellen Durchlauf</li>
                <li><code>for (let i = 0; i &lt; 10; i++) { if (i === 5) break; }</code><br><strong>Fix:</strong>
                    <code>break</code> beendet die Schleife vorzeitig</li>
                <li><code>for (let i = 0; i &lt; 10; i++) { if (i === 5) return; }</code><br><strong>Fix:</strong>
                    <code>return</code> beendet die Funktion vorzeitig</li>
            </ol>
        </section>

        <section class="chapter">
            <h2>Zusammenfassung ğŸ“š</h2>
            <p>
                Schleifen sind mÃ¤chtig - aber du musst wissen, wann du den RÃ¼ckzug antreten solltest! Mit
                <code>break</code>, <code>continue</code> und <code>return</code> steuerst du den Flow wie ein wahrer
                Spielleiter. Nutze diese Skills weise, junger Code-Magier - sie werden dir in vielen Quest-Logiken von
                Nutzen sein! ğŸ§™â€â™€ï¸
            </p>
            <p>
                Und vergiss nicht: Ãœbung macht den Meister! Also schnapp dir deinen Code und leg los! Und wenn du
                Fragen hast, zÃ¶gere nicht, uns zu fragen - wir sind hier, um dir zu helfen! ğŸ’ª
            </p>
            <p>
                Wir hoffen, du hattest SpaÃŸ beim Lernen und bist bereit, deine neuen FÃ¤higkeiten in die Tat
                umzusetzen! Und denk daran: Programmieren ist wie ein Abenteuer - manchmal musst du Risiken eingehen und
                neue Wege ausprobieren, um ans Ziel zu kommen! ğŸš€
            </p>
            <p>
                Also, worauf wartest du noch? Schnapp dir deinen Code und leg los! Und vergiss nicht, uns deine
                Ergebnisse zu zeigen - wir sind gespannt auf deine Abenteuer! ğŸ‰
            </p>
        </section>

        <section class="playground">
<textarea id="codeInput" rows="30" cols="120">// Hier kannst du deinen Code eintippen und testen
// Beispiel: Loot durchsuchen mit break
let beute = ["MÃ¼nzen", "Fass", "Buch", "Zauberstab", "LegendÃ¤res Item"];

for (let i = 0; i &lt; beute.length; i++) {
if (beute[i] === "LegendÃ¤res Item") {
console.log("Gefunden: " + beute[i] + " ğŸ‰");
break;
}
console.log("Durchsucht: " + beute[i]);
}</textarea><br>
            <button onclick="runCode()">Code ausfÃ¼hren</button><br>
            <pre id="output"></pre><br>
            <p>Teste deinen Code z.B. im <a href="https://developer.mozilla.org/de/play" target="_blank">MDN
                    Playground</a></p>
        </section>

        <section class="end">
            <a href="./Funktionen_erstellen_und_aufrufen.html"><button>Zum nÃ¤chsten Thema</button></a>
        </section>
        <script src="../../../src/js/main.js"></script>

    </main>

    <footer>
        &copy; 2025 CodeBloom. Alle Rechte vorbehalten.
    </footer>
</body>

</html>